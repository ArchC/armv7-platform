This is the ARMv7 ArchC 2.1 functional model (system-level).

In order to test system-level, simple test platform is implemented in main.cpp.
This platform also has a custom Makefile in Makefile.platform. Do not
make -f Makefile.archc distclean, since it will delete main.cpp and custom
header files. Also, avoid using the automatically generated Makefile.archc
Makefile, since it will not compile necessary modules needed by the platform.

:: Install ::

The first step is to automatically generate the ARM SystemC processor
core using ArchC. If you are using the canonical ArchC release, you must
use the parameter -ndc to disable decoded cache. This will make your
simulation slower but allows self-modifying code and reduces the amount
of memory required to run the model.  *NOT RECOMMENDED*
You may also run into many sorts of trouble while using the canonical
ArchC.

The recommended way to generate and use the ARM processor Core is *to
use our modified version of ArchC* that implements support to self
modifying code and many other features useful to this plataform
model. This version can be obtained here: ---

To generate the processor core using this modified version, you can do:

   $   acsim arm.ac -np                  (use -gdb if you want to debug)
   $   make -f Makefile.platform

:: Running the simulator ::

The system level model requires you to put some code at address 0x0,
where lies a read-only memory, that is the first code executed by the
model. You can add a raw binary there using the --rom option. like this

   $    arm-sim --rom=<path_to_boot_code>

We provide a experimental code that performs a bootstrap of the system
and boots from a SD card connected to the model. The bootstrap code can
be used as follows:

   $  arm-sim --rom=dumboot.bin --sd=<sdcard_image>

On the above example, we passed an sdcard image for the simulator, using
the --sd option.

The simulator allows you to connect a GDB compiled for an arm target and
use it for debugging purposes. To connect it, you must tell the
simulator to wait for a GDB connection, as follows:

   $  arm-sim --rom=dumboot.bin --sd=<sdcard_image> --gdb

You can also use the log feature on the simulator to print useful
information about executed instructions, state of peripherals, etc. To
use it, you may set the -D option, selecting the devices you want to
log. If you are interested on observing the bus traffic, and the
instructions executed, for instance, you can type:

   $  arm-sim --rom=dumboot.bin --sd=<sdcard_image> -D core,bus

:: Multiple processor instances ::

The current model does not support more than one core instantiated in the same
SystemC simulation. The reason is that arm_isa.cpp implements some state
variables as global variables to speed up simulation, and instantiated multiple
cores will cause unwanted sharing of processor state between processor
instances.

:: Binary automatic generation ::

    acbingen.sh -i<abs-install-path> -a<arch-name> arm.ac

This will generate the tools source files using the architecture
name <arch-name> (if omitted, arm is used), copy them to the
binutils source tree, build and install them into the directory
<abs-install-path> (which -must- be an absolute path).
Use "acbingen.sh -h" to get information about the command-line
options available.


For more information visit http://www.archc.org


CHANGELOG:
==========

Version 0.8.0:

- System level model implemented
- Support for automatic compiler generation
- Model passed selected Mediabench and Mibench applications
- ArchC 2.1 compliant
- Support for automatic generation of binary tools
- Support for dynamic linker and loader when reading ELF files
- Support for GDB
- Support for compiled simulator and interpreted simulator
